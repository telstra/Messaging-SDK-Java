/*
 * Messaging API v3.1.0
 * Send and receive SMS & MMS programmatically, leveraging Australia's leading mobile network. With Telstra's Messaging API, we take out the complexity to allow seamless messaging integration into your app, with just a few lines of code. Our REST API is enterprise grade, allowing you to communicate with engaging SMS & MMS messaging in your web and mobile apps in near real-time on a global scale. 
 *
 * OpenAPI spec version: 3.1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package com.telstra;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.v3.oas.annotations.media.Schema;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import org.threeten.bp.OffsetDateTime;
/**
 * MessageUpdate
 */


public class MessageUpdate {
  @SerializedName("messageId")
  private UUID messageId = null;

  /**
   * The status will be either queued, sent, delivered, expired or undeliverable.
   */
  @JsonAdapter(StatusEnum.Adapter.class)
  public enum StatusEnum {
    QUEUED("queued"),
    SENT("sent"),
    DELIVERED("delivered"),
    EXPIRED("expired"),
    UNDELIVERABLE("undeliverable");

    private String value;

    StatusEnum(String value) {
      this.value = value;
    }
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }
    public static StatusEnum fromValue(String input) {
      for (StatusEnum b : StatusEnum.values()) {
        if (b.value.equals(input)) {
          return b;
        }
      }
      return null;
    }
    public static class Adapter extends TypeAdapter<StatusEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final StatusEnum enumeration) throws IOException {
        jsonWriter.value(String.valueOf(enumeration.getValue()));
      }

      @Override
      public StatusEnum read(final JsonReader jsonReader) throws IOException {
        Object value = jsonReader.nextString();
        return StatusEnum.fromValue((String)(value));
      }
    }
  }  @SerializedName("status")
  private StatusEnum status = null;

  @SerializedName("to")
  private String to = null;

  @SerializedName("from")
  private String from = null;

  @SerializedName("messageContent")
  private String messageContent = null;

  @SerializedName("multimedia")
  private List<MultimediaGet> multimedia = null;

  @SerializedName("retryTimeout")
  private Integer retryTimeout = null;

  @SerializedName("scheduleSend")
  private OffsetDateTime scheduleSend = null;

  @SerializedName("deliveryNotification")
  private Boolean deliveryNotification = false;

  @SerializedName("statusCallbackUrl")
  private String statusCallbackUrl = null;

  @SerializedName("queuePriority")
  private Integer queuePriority = 2;

  @SerializedName("tags")
  private List<String> tags = null;

  public MessageUpdate messageId(UUID messageId) {
    this.messageId = messageId;
    return this;
  }

   /**
   * Use this UUID with our other endpoints to fetch, update or delete the message.
   * @return messageId
  **/
  @Schema(description = "Use this UUID with our other endpoints to fetch, update or delete the message.")
  public UUID getMessageId() {
    return messageId;
  }

  public void setMessageId(UUID messageId) {
    this.messageId = messageId;
  }

  public MessageUpdate status(StatusEnum status) {
    this.status = status;
    return this;
  }

   /**
   * The status will be either queued, sent, delivered, expired or undeliverable.
   * @return status
  **/
  @Schema(description = "The status will be either queued, sent, delivered, expired or undeliverable.")
  public StatusEnum getStatus() {
    return status;
  }

  public void setStatus(StatusEnum status) {
    this.status = status;
  }

  public MessageUpdate to(String to) {
    this.to = to;
    return this;
  }

   /**
   * The recipient&#x27;s mobile number.
   * @return to
  **/
  @Schema(description = "The recipient's mobile number.")
  public String getTo() {
    return to;
  }

  public void setTo(String to) {
    this.to = to;
  }

  public MessageUpdate from(String from) {
    this.from = from;
    return this;
  }

   /**
   * This will be either \&quot;privateNumber\&quot;, one of your Virtual Numbers or your senderName.
   * @return from
  **/
  @Schema(description = "This will be either \"privateNumber\", one of your Virtual Numbers or your senderName.")
  public String getFrom() {
    return from;
  }

  public void setFrom(String from) {
    this.from = from;
  }

  public MessageUpdate messageContent(String messageContent) {
    this.messageContent = messageContent;
    return this;
  }

   /**
   * The content of the message.
   * @return messageContent
  **/
  @Schema(description = "The content of the message.")
  public String getMessageContent() {
    return messageContent;
  }

  public void setMessageContent(String messageContent) {
    this.messageContent = messageContent;
  }

  public MessageUpdate multimedia(List<MultimediaGet> multimedia) {
    this.multimedia = multimedia;
    return this;
  }

  public MessageUpdate addMultimediaItem(MultimediaGet multimediaItem) {
    if (this.multimedia == null) {
      this.multimedia = new ArrayList<MultimediaGet>();
    }
    this.multimedia.add(multimediaItem);
    return this;
  }

   /**
   * The multimedia content of the message (MMS only). It will include: 
   * @return multimedia
  **/
  @Schema(description = "The multimedia content of the message (MMS only). It will include: ")
  public List<MultimediaGet> getMultimedia() {
    return multimedia;
  }

  public void setMultimedia(List<MultimediaGet> multimedia) {
    this.multimedia = multimedia;
  }

  public MessageUpdate retryTimeout(Integer retryTimeout) {
    this.retryTimeout = retryTimeout;
    return this;
  }

   /**
   * How many minutes you asked the server to keep trying to send the message.
   * minimum: 1
   * maximum: 1440
   * @return retryTimeout
  **/
  @Schema(description = "How many minutes you asked the server to keep trying to send the message.")
  public Integer getRetryTimeout() {
    return retryTimeout;
  }

  public void setRetryTimeout(Integer retryTimeout) {
    this.retryTimeout = retryTimeout;
  }

  public MessageUpdate scheduleSend(OffsetDateTime scheduleSend) {
    this.scheduleSend = scheduleSend;
    return this;
  }

   /**
   * The time the message is scheduled to send.
   * @return scheduleSend
  **/
  @Schema(description = "The time the message is scheduled to send.")
  public OffsetDateTime getScheduleSend() {
    return scheduleSend;
  }

  public void setScheduleSend(OffsetDateTime scheduleSend) {
    this.scheduleSend = scheduleSend;
  }

  public MessageUpdate deliveryNotification(Boolean deliveryNotification) {
    this.deliveryNotification = deliveryNotification;
    return this;
  }

   /**
   * If set to **true**, you will receive a notification to the statusCallbackUrl when your message is delivered (paid feature).
   * @return deliveryNotification
  **/
  @Schema(description = "If set to **true**, you will receive a notification to the statusCallbackUrl when your message is delivered (paid feature).")
  public Boolean isDeliveryNotification() {
    return deliveryNotification;
  }

  public void setDeliveryNotification(Boolean deliveryNotification) {
    this.deliveryNotification = deliveryNotification;
  }

  public MessageUpdate statusCallbackUrl(String statusCallbackUrl) {
    this.statusCallbackUrl = statusCallbackUrl;
    return this;
  }

   /**
   * The URL the API will call when the status of the message changes.
   * @return statusCallbackUrl
  **/
  @Schema(description = "The URL the API will call when the status of the message changes.")
  public String getStatusCallbackUrl() {
    return statusCallbackUrl;
  }

  public void setStatusCallbackUrl(String statusCallbackUrl) {
    this.statusCallbackUrl = statusCallbackUrl;
  }

  public MessageUpdate queuePriority(Integer queuePriority) {
    this.queuePriority = queuePriority;
    return this;
  }

   /**
   * The priority assigned to the message.
   * minimum: 1
   * maximum: 3
   * @return queuePriority
  **/
  @Schema(example = "2", description = "The priority assigned to the message.")
  public Integer getQueuePriority() {
    return queuePriority;
  }

  public void setQueuePriority(Integer queuePriority) {
    this.queuePriority = queuePriority;
  }

  public MessageUpdate tags(List<String> tags) {
    this.tags = tags;
    return this;
  }

  public MessageUpdate addTagsItem(String tagsItem) {
    if (this.tags == null) {
      this.tags = new ArrayList<String>();
    }
    this.tags.add(tagsItem);
    return this;
  }

   /**
   * Any customisable tags assigned to the message.
   * @return tags
  **/
  @Schema(description = "Any customisable tags assigned to the message.")
  public List<String> getTags() {
    return tags;
  }

  public void setTags(List<String> tags) {
    this.tags = tags;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MessageUpdate messageUpdate = (MessageUpdate) o;
    return Objects.equals(this.messageId, messageUpdate.messageId) &&
        Objects.equals(this.status, messageUpdate.status) &&
        Objects.equals(this.to, messageUpdate.to) &&
        Objects.equals(this.from, messageUpdate.from) &&
        Objects.equals(this.messageContent, messageUpdate.messageContent) &&
        Objects.equals(this.multimedia, messageUpdate.multimedia) &&
        Objects.equals(this.retryTimeout, messageUpdate.retryTimeout) &&
        Objects.equals(this.scheduleSend, messageUpdate.scheduleSend) &&
        Objects.equals(this.deliveryNotification, messageUpdate.deliveryNotification) &&
        Objects.equals(this.statusCallbackUrl, messageUpdate.statusCallbackUrl) &&
        Objects.equals(this.queuePriority, messageUpdate.queuePriority) &&
        Objects.equals(this.tags, messageUpdate.tags);
  }

  @Override
  public int hashCode() {
    return Objects.hash(messageId, status, to, from, messageContent, multimedia, retryTimeout, scheduleSend, deliveryNotification, statusCallbackUrl, queuePriority, tags);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("{\n");
    sb.append("    messageId: ").append(toIndentedString(messageId)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    to: ").append(toIndentedString(to)).append("\n");
    sb.append("    from: ").append(toIndentedString(from)).append("\n");
    sb.append("    messageContent: ").append(toIndentedString(messageContent)).append("\n");
    sb.append("    multimedia: ").append(toIndentedString(multimedia)).append("\n");
    sb.append("    retryTimeout: ").append(toIndentedString(retryTimeout)).append("\n");
    sb.append("    scheduleSend: ").append(toIndentedString(scheduleSend)).append("\n");
    sb.append("    deliveryNotification: ").append(toIndentedString(deliveryNotification)).append("\n");
    sb.append("    statusCallbackUrl: ").append(toIndentedString(statusCallbackUrl)).append("\n");
    sb.append("    queuePriority: ").append(toIndentedString(queuePriority)).append("\n");
    sb.append("    tags: ").append(toIndentedString(tags)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}
